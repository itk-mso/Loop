<?php

/**
 * @file
 * Code for the Loop Notification feature.
 */

include_once 'loop_notification.features.inc';

/**
 * Implements hook_menu().
 *
 * A menu item linking to an administration form.
 */
function loop_notification_menu() {
  $items = [];

  $items['admin/config/loop/notifications'] = [
    'title' => 'Loop notification settings',
    'description' => 'Settings related to the notification module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['loop_notification_config_form'],
    'access arguments' => ['access administration pages'],
  ];

  return $items;
}

/**
 * Implements hook_form().
 *
 * A form for managing this modules configuration.
 */
function loop_notification_config_form($form) {
  $checkboxes = node_type_get_names();

  $form['loop_notification_wrapper'] = [
    '#type' => 'fieldset',
    '#title' => 'Enable notifications',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  ];

  $form['loop_notification_wrapper']['loop_notification_content_types'] = [
    '#type' => 'checkboxes',
    '#options' => $checkboxes,
    '#default_value' => variable_get('loop_notification_content_types'),
    '#title' => 'Select content types',
    '#description' => t('Select the content types where you want notifications enabled.'),
  ];

  $form['loop_notification_wrapper']['loop_notification_default_interval'] = [
    '#type' => 'numberfield',
    '#required' => TRUE,
    '#default_value' => variable_get('loop_notification_default_interval'),
    '#title' => t('Notification default interval'),
    '#description' => t('Default number of seconds between notification updates. Used if the user has not chosen a value.'),
  ];

  $form['loop_notification_wrapper']['loop_notification_evaluation_interval'] = [
    '#type' => 'numberfield',
    '#required' => TRUE,
    '#default_value' => variable_get('loop_notification_evaluation_interval'),
    '#title' => t('Notification evaluation interval'),
    '#description' => t('How often should the notification evaluation run (in seconds)?'),
  ];

  $form['loop_notification_email_wrapper'] = [
    '#type' => 'fieldset',
    '#title' => t('Loop e-mail templates'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#description' => t('Loop e-mail templates. See below for a list of available tokens.'),
  ];

  $form['loop_notification_email_wrapper']['info'] = [
    '#markup' => t('Sender name and e-mail are set in <a href="@url">Mime Mail settings</a>.',
      ['@url' => url('admin/config/system/mimemail')]),
    '#prefix' => '<p><em>',
    '#suffix' => '</em></p>',
  ];

  $form['loop_notification_email_wrapper']['templates'] = [
    '#type' => 'vertical_tabs',
  ];

  $form['loop_notification_email_wrapper']['templates']['loop_notification_send_mail'] = [
    '#type' => 'fieldset',
    '#title' => t('Send mail to subscribers'),

    'loop_notification_send_mail_subject' => [
      '#type' => 'textfield',
      '#default_value' => variable_get('loop_notification_send_mail_subject'),
      '#title' => t('Subject'),
    ],

    'loop_notification_send_mail_body' => [
      '#type' => 'textarea',
      '#default_value' => variable_get('loop_notification_send_mail_body'),
      '#title' => t('Body'),
    ],
  ];

  $form['loop_notification_email_wrapper']['custom_tokens'] = [
    '#markup' =>
      '<li>' . t('@token - New questions', ['@token' => '[loop:question_new]']) . '</li>' .
      '<li>' . t('@token - Changed questions', ['@token' => '[loop:question_changes]']) . '</li>' .
      '<li>' . t('@token - New answers', ['@token' => '[loop:answer_new]']) . '</li>' .
      '<li>' . t('@token - Changed answers', ['@token' => '[loop:answer_changes]']) . '</li>' .
      '<li>' . t('@token - New document collections', ['@token' => '[loop:document_collection_new]']) . '</li>' .
      '<li>' . t('@token - Changed document collections', ['@token' => '[loop:document_collection_changes]']) . '</li>' .
      '<li>' . t('@token - New documents', ['@token' => '[loop:document_new]']) . '</li>' .
      '<li>' . t('@token - Changed documents', ['@token' => '[loop:document_changes]']) . '</li>'
    ,
    '#prefix' => '<p><h4>' . t('Custom tokens') . '</h4><ul>',
    '#suffix' => '</ul></p>',
  ];

  $form['loop_notification_email_wrapper']['tokens'] = _loop_notification_get_email_tokens();

  return system_settings_form($form);
}

/**
 * Implements hook_loop_notification_message_recipient_alter().
 *
 * Modify the array of message recipients.
 */
function loop_notification_loop_notification_message_recipient_alter(
  &$users,
  $node
) {
  // Fetch users who flagged the node.
  $query = db_select('flagging', 'f')
    ->fields('f', ['uid']);
  $query->innerJoin('flag', 'l', 'f.fid = l.fid', []);
  $query->condition('f.entity_id', $node->nid, '=');
  $query->condition('f.entity_type', 'node', '=');

  $result = $query->execute()->fetchCol();
  $users = array_merge($result, $users);
}

/**
 * Implements hook_node_insert().
 *
 * Invoke rules components when creating a new node.
 */
function loop_notification_node_insert($node) {
  _loop_notification_notify_users($node, 'insert');
}

/**
 * Implements hook_node_update().
 *
 * Invoke rules components when updating a node.
 */
function loop_notification_node_update($node) {
  _loop_notification_notify_users($node, 'update');
}

/**
 * Implements hook_comment_insert().
 *
 * Invoke rules components when creating a new comment.
 */
function loop_notification_comment_insert($comment) {
  _loop_notification_notify_users(node_load($comment->nid), 'insert', $comment);
}

/**
 * Implements hook_comment_update().
 *
 * Invoke rules components when updating a comment.
 */
function loop_notification_comment_update($comment) {
  _loop_notification_notify_users(node_load($comment->nid), 'update', $comment);
}

/**
 * Implements hook_cron().
 *
 *
 */
function loop_notification_cron() {
  $last_cron = (int) variable_get('loop_notification_last_cron');
  $cron_interval = (int) variable_get('loop_notification_evaluation_interval');

  $now = time();

  if (is_null($cron_interval)) {
    $cron_interval = 60 * 60 * 24; // Defaults to once pr. day.
  }

  // Default last cron to now, to avoid sending old notifications.
  if (is_null($last_cron)) {
    $last_cron = $now;
    variable_set('loop_notification_last_cron', $last_cron);
  }

  if ($last_cron + $cron_interval < $now) {
    _loop_notification_send_notifications();

    variable_set('loop_notification_last_cron', time());
  }
}

/**
 * Get email tokens.
 *
 * These are provided by the Rules module.
 */
function _loop_notification_get_email_tokens() {
  $render = RulesTokenEvaluator::help([
    'site' => [
      'type' => 'site',
      'label' => 'Site information',
      'description' => 'Site-wide settings and other global information.',
      'property info alter' => [
        0 => 'RulesData',
        1 => 'addSiteMetadata',
      ],
      'property info' => [],
      'optional' => TRUE,
    ],
    'user' => [
      'label' => 'user',
      'type' => 'user',
    ],
  ]);

  return $render;
}

/**
 * Loop through recipients to send notification.
 *
 * @param object $node
 *   The node related to the message about to be created.
 * @param string $action
 *   The action that triggered the notification, insert or update.
 * @param object|null $comment
 *   A comment if the action was triggered by a new or updated comment.
 */
function _loop_notification_notify_users($node, $action, $comment = NULL) {
  if (_loop_notification_check_content_type($node)) {
    // Fetch all recipients.
    $users = _loop_notification_find_users($node);

    // Only load the entity_author once.
    $author = $comment ? user_load($comment->uid) : user_load($node->uid);

    // Notify all subscribed users.
    foreach ($users as $user) {
      _loop_notification_notify_user($user, $node, $action, $author, $comment);
    }
  }
}

/**
 * Provide the list of users to be notified.
 *
 * @param object $node
 *   The node related to the message about to be created.
 *
 * @return array
 *   The list of user entities that should receive the notification.
 */
function _loop_notification_find_users($node) {
  $user_ids = [];
  // Allow other modules to modify the list of recipients.
  drupal_alter('loop_notification_message_recipient', $user_ids, $node);

  // Remove recurring users.
  $user_ids = array_unique($user_ids);

  $users = [];
  foreach ($user_ids as $id) {
    // Load the user object.
    $users[] = user_load($id);
  }
  return $users;
}

/**
 * Invoke rules components depending on situation.
 *
 * @param object $user
 *   A user about to receive a notification.
 * @param object $node
 *   The node related to the message about to be created.
 * @param string $action
 *   The action that triggered the notification, insert or update.
 * @param object $author
 *   The author of the entity that triggered the notification.
 * @param object|null $comment
 *   A comment if the action was triggered by a new or updated comment.
 */
function _loop_notification_notify_user(
  $user,
  $node,
  $action,
  $author,
  $comment = NULL
) {
  // Create messages related to comment actions.
  if ($comment) {
    if ($action == 'insert') {
      // Insert comment notification.
      rules_invoke_component('rules_create_notification', $user, $author,
        $comment);
    }
    else {
      // Update comment notification.
      rules_invoke_component('loop_notification_create_notification_on_comment_edit',
        $user, $author, $comment);
    }
  }
  // Create messages related to node actions.
  else {
    if ($action == 'insert') {
      // Insert node notification.
      rules_invoke_component('loop_notification_create_notification_on_node_create',
        $user, $author, $node);
    }
    else {
      // Update node notification.
      rules_invoke_component('loop_notification_create_notification_on_node_edit',
        $user, $author, $node);
    }
  }
}

/**
 * Check for content type.
 *
 * @param object $node
 *   The node related to the message about to be created.
 *
 * @return bool
 *   Whether or not the configuration allows the content type to send
 *   notifcations.
 */
function _loop_notification_check_content_type($node) {
  $allowed_types = variable_get('loop_notification_content_types');
  return !empty($allowed_types[$node->type]);
}

/**
 * Get nodes that have been changes since $modification_limit.
 *
 * @param $modification_limit
 *   The unix timestamp from which to get modifications from.
 *
 * @return array
 *   Array of nodes that have been modified since $modification_limit.
 */
function _loop_notification_modified_nodes($modification_limit) {
  $nodes = [];

  $query = new EntityFieldQuery();

  try {
    $query->entityCondition('entity_type', 'node')
      ->propertyCondition('changed', $modification_limit, '>');
  } catch (EntityFieldQueryException $e) {
    // Ignore error. Return empty array.
    // @TODO: Write error to log.
    return $nodes;
  }

  $result = $query->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    $nodes = entity_load('node', $nids);
  }

  return $nodes;
}

/**
 * Get all comments that where created after $loop_notification_last_cron.
 *
 * @param $loop_notification_last_cron
 *   The timestamp to delimit search.
 *
 * @return array
 */
function _loop_notification_new_comments($loop_notification_last_cron) {
  $result = db_query('SELECT nid FROM {comment} WHERE created > :timestamp AND status = :status', array(
    ':timestamp' => $loop_notification_last_cron,
    ':status' => COMMENT_PUBLISHED,
  ))
    ->fetchCol();

  return array_values(array_unique($result));
}

/**
 * Get all comments that where modified (but not created) after $loop_notification_last_cron.
 *
 * @param $loop_notification_last_cron
 *   The timestamp to delimit search.
 *
 * @return array
 */
function _loop_notification_modified_comments($loop_notification_last_cron) {
  $result = db_query('SELECT nid FROM {comment} WHERE changed > :timestamp AND created < :timestamp AND status = :status', array(
    ':timestamp' => $loop_notification_last_cron,
    ':status' => COMMENT_PUBLISHED,
  ))
    ->fetchCol();

  return array_values(array_unique($result));
}

/**
 * Create a list element of the link to a node.
 *
 * @param $node
 *   The node to link to.
 *
 * @return string
 */
function _loop_notification_create_list_element($node) {
  $link = l($node->title, $alias = drupal_get_path_alias('node/' . $node->nid));

  return '<li>' . $link . '</li>';
}

/**
 * Updated the relevant arrays for handling a changes.
 *
 * @param $nid
 *   The node id to add.
 * @param $users_to_notify
 *   The users to notify.
 * @param $node_array
 *   Array of nodes linked to created/changed.
 * @param $list_array
 *   The array of list elements.
 * @param $timestamp
 *   The time to compare interval overlaps with.
 * @param $loop_notification_last_user_notifications
 *   Array of timestamps with uid as key.
 * @param $content_types
 *   Array of content_types to receive notifications for.
 */
function _loop_notification_handle_nodes($nid, &$users_to_notify, &$node_array, &$list_array, $timestamp, $loop_notification_last_user_notifications, $content_types) {
  $node = node_load($nid);

  // Make sure notifications are activated for the given node type.
  if (empty($content_types[$node->type]) || !$content_types[$node->type]) {
    return;
  }

  $users = _loop_notification_find_users($node);

  $node_array[$nid] = $node;

  $list_array[$nid] = _loop_notification_create_list_element($node);

  foreach ($users as $user) {
    // Defaults to once pr. week.
    $user_notification_interval = variable_get('loop_notification_default_interval') ?: 60 * 60 * 24 * 7;

    if ($timestamp > $loop_notification_last_user_notifications[$user->id] + $user_notification_interval) {
      $users_to_notify[$user->uid][$node->nid] = $node->nid;
    }
  }
}

/**
 * Sends notifications to all users of changes to the content they subscribe to
 * that has changed or been created, since the last notification mail was sent.
 */
function _loop_notification_send_notifications() {
  $now = time();

  // Get the last time notifications where sent.
  $loop_notification_last_cron = variable_get('loop_notification_last_cron');

  // Get mail templates.
  $mail_template = variable_get('loop_notification_send_mail_body');
  $mail_subject = variable_get('loop_notification_send_mail_subject');

  // Get the content types where notifications are enabled.
  $content_types = variable_get('loop_notification_content_types');

  // Get the last user notifications time.
  $loop_notification_last_user_notifications = variable_get('loop_notification_last_user_notifications');
  if (is_null($loop_notification_last_user_notifications)) {
    $loop_notification_last_user_notifications = [];
  }

  $node_array = [];
  $nodes_changed = [];
  $nodes_created = [];

  $comment_array = [];
  $comments_changed = [];
  $comments_created = [];

  // Users that should be notified.
  $user_nodes = [];

  // Get nodes that have been created_nodes_to_send/modified since loop_notification_last_cron.
  $modified_nodes = _loop_notification_modified_nodes($loop_notification_last_cron);

  // Handle each created_nodes_to_send comment.
  $nids_with_new_comments = _loop_notification_new_comments($loop_notification_last_cron);
  foreach ($nids_with_new_comments as $nid) {
    _loop_notification_handle_nodes($nid, $user_nodes, $comment_array, $comments_created, $now, $loop_notification_last_user_notifications, $content_types);
  }

  // Handle each changed_nodes_to_send comment.
  $nids_with_modified_comments = _loop_notification_modified_comments($loop_notification_last_cron);
  foreach ($nids_with_modified_comments as $nid) {
    _loop_notification_handle_nodes($nid, $user_nodes, $comment_array, $comments_changed, $now, $loop_notification_last_user_notifications, $content_types);
  }

  // Handle each created_nodes_to_send/changed_nodes_to_send node.
  foreach ($modified_nodes as $node) {
    // Sort by created_nodes_to_send/changed_nodes_to_send.
    if ($node->created > $loop_notification_last_cron) {
      _loop_notification_handle_nodes($node->nid, $user_nodes, $node_array, $nodes_created[$node->type], $now, $loop_notification_last_user_notifications, $content_types);
    }
    else {
      _loop_notification_handle_nodes($node->nid, $user_nodes, $node_array, $nodes_changed[$node->type], $now, $loop_notification_last_user_notifications, $content_types);
    }
  }

  // Create notification mail to each user that have notifications waiting.
  foreach ($user_nodes as $user_key => $user_nids) {
    $changed_nodes_to_send = [];
    $created_nodes_to_send = [];
    $created_comments_to_send = [];
    $changed_comments_to_send = [];

    // Extract changes to user.
    foreach ($user_nids as $nid) {
      $node = $node_array[$nid];

      if (isset($nodes_changed[$node->type][$nid])) {
        $changed_nodes_to_send[$node->type][] = $nodes_changed[$node->type][$nid];
      }
      else if (isset($nodes_created[$node->type][$nid])) {
        $created_nodes_to_send[$node->type][] = $nodes_created[$node->type][$nid];
      }

      if (in_array($nid, $nids_with_new_comments)) {
        $created_comments_to_send[] = $comments_created[$nid];
      }

      if (in_array($nid, $nids_with_modified_comments)) {
        $changed_comments_to_send[] = $comments_changed[$nid];
      }
    }

    $custom_tokens = [
      '[loop:answer_new]' => '<ul>' . implode('', $created_comments_to_send) . '</ul>',
      '[loop:answer_changes]' => '<ul>' . implode('', $changed_comments_to_send) . '</ul>',
      '[loop:question_new]' => '<ul>' . implode('', $created_nodes_to_send['post']) . '</ul>',
      '[loop:question_changes]' => '<ul>' . implode('', $changed_nodes_to_send['post']) . '</ul>',
      '[loop:document_collection_new]' => '<ul>' . implode('', $created_nodes_to_send['loop_documents_collection']) . '</ul>',
      '[loop:document_collection_changes]' => '<ul>' . implode('', $changed_nodes_to_send['loop_documents_collection']) . '</ul>',
      '[loop:document_new]' => '<ul>' . implode('', $created_nodes_to_send['loop_documents_document']) . '</ul>',
      '[loop:document_changes]' => '<ul>' . implode('', $changed_nodes_to_send['loop_documents_document']) . '</ul>',
    ];

    // Replace end of lines.
    $mail_template = str_replace(["\r\n", "\r", "\n"], '<br/>', $mail_template);

    // Replace loop tokens.
    $body = _loop_notification_replace_loop_tokens($mail_template, $custom_tokens);
    $subject = _loop_notification_replace_loop_tokens($mail_subject, $custom_tokens);

    // Load the user.
    $user = user_load($user_key);

    // Regular token replacement.
    $body = token_replace($body, ['user' => $user]);
    $subject = token_replace($subject, ['user' => $user]);

    _loop_notification_mail_send($subject, $body, $user);

    // Update the time when the user has last received notifications.
    $loop_notification_last_user_notifications[$user_key] = $now;
  }

  variable_set('loop_notification_last_user_notifications',
    $loop_notification_last_user_notifications);
}

/**
 * Replace  tokens.
 *
 * @param $text
 *   The text to replace in.
 * @param array $replacements
 *   An optional array of replacements of the form:
 *   ['custom_token' => 'replacement', ...]
 *
 * @return null|string|string[]
 */
function _loop_notification_replace_loop_tokens($text, $replacements = []) {
  foreach ($replacements as $key => $replacement) {
    $text = str_replace($key, $replacement, $text);
  }

  return $text;
}

/**
 * Send a notification mail.
 *
 * @param $subject
 *   The subject.
 * @param $message
 *   The message.
 * @param $to
 *   The receiver.
 * @param null $from
 *   The sender.
 */
function _loop_notification_mail_send($subject, $message, $to, $from = NULL) {
  $params = [
    'subject' => $subject,
    'body' => $message,
  ];

  $result = drupal_mail('loop_notification', 'notify', $to,
    user_preferred_language($to), $params, $from, TRUE);
  if ($result['result'] != TRUE) {
    watchdog('loop_notification', 'Mail error', [], WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_mail().
 */
function loop_notification_mail($key, &$message, $params) {
  $message['headers']['MIME-Version'] = '1.0';
  $message['headers']['Content-Type'] = 'multipart/mixed;';
  $message['headers']['Content-Type'] = 'text/html;';

  $message['subject'] = $params['subject'];
  $message['body'][] = $params['body'];
}
